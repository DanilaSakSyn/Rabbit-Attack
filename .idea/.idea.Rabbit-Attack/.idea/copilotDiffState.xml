<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopCurrencyDisplay.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopCurrencyDisplay.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;public class ShopCurrencyDisplay : MonoBehaviour&#10;{&#10;    [Header(&quot;Currency UI Elements&quot;)]&#10;    [SerializeField] private TextMeshProUGUI coinsText;&#10;    [SerializeField] private TextMeshProUGUI gemsText;&#10;    [SerializeField] private TextMeshProUGUI energyText;&#10;    [SerializeField] private TextMeshProUGUI livesText;&#10;    &#10;    [Header(&quot;Currency Icons&quot;)]&#10;    [SerializeField] private Image coinsIcon;&#10;    [SerializeField] private Image gemsIcon;&#10;    [SerializeField] private Image energyIcon;&#10;    [SerializeField] private Image livesIcon;&#10;    &#10;    [Header(&quot;Animation Settings&quot;)]&#10;    [SerializeField] private bool animateOnChange = true;&#10;    [SerializeField] private float animationDuration = 0.3f;&#10;    [SerializeField] private AnimationCurve animationCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);&#10;    &#10;    private void OnEnable()&#10;    {&#10;        // Подписываемся на события изменения валют&#10;        Wallet.OnCoinsChanged += UpdateCoinsDisplay;&#10;        Wallet.OnGemsChanged += UpdateGemsDisplay;&#10;        Wallet.OnEnergyChanged += UpdateEnergyDisplay;&#10;        Wallet.OnLivesChanged += UpdateLivesDisplay;&#10;        &#10;        // Обновляем отображение при включении&#10;        if (Wallet.Instance != null)&#10;        {&#10;            UpdateAllDisplays();&#10;        }&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        // Отписываемся от событий&#10;        Wallet.OnCoinsChanged -= UpdateCoinsDisplay;&#10;        Wallet.OnGemsChanged -= UpdateGemsDisplay;&#10;        Wallet.OnEnergyChanged -= UpdateEnergyDisplay;&#10;        Wallet.OnLivesChanged -= UpdateLivesDisplay;&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        UpdateAllDisplays();&#10;    }&#10;    &#10;    private void UpdateAllDisplays()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            UpdateCoinsDisplay(Wallet.Instance.Coins);&#10;            UpdateGemsDisplay(Wallet.Instance.Gems);&#10;            UpdateEnergyDisplay(Wallet.Instance.Energy);&#10;            UpdateLivesDisplay(Wallet.Instance.Lives);&#10;        }&#10;    }&#10;    &#10;    private void UpdateCoinsDisplay(int amount)&#10;    {&#10;        if (coinsText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(coinsText, amount);&#10;            else&#10;                coinsText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateGemsDisplay(int amount)&#10;    {&#10;        if (gemsText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(gemsText, amount);&#10;            else&#10;                gemsText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateEnergyDisplay(int amount)&#10;    {&#10;        if (energyText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(energyText, amount);&#10;            else&#10;                energyText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateLivesDisplay(int amount)&#10;    {&#10;        if (livesText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(livesText, amount);&#10;            else&#10;                livesText.text = amount.ToString();&#10;        }&#10;    }&#10;    &#10;    private string FormatCurrency(int amount)&#10;    {&#10;        if (amount &gt;= 1000000)&#10;            return (amount / 1000000f).ToString(&quot;F1&quot;) + &quot;M&quot;;&#10;        else if (amount &gt;= 1000)&#10;            return (amount / 1000f).ToString(&quot;F1&quot;) + &quot;K&quot;;&#10;        else&#10;            return amount.ToString();&#10;    }&#10;    &#10;    private void AnimateText(TextMeshProUGUI textComponent, int targetValue)&#10;    {&#10;        if (textComponent == null) return;&#10;        &#10;        StartCoroutine(AnimateTextCoroutine(textComponent, targetValue));&#10;    }&#10;    &#10;    private System.Collections.IEnumerator AnimateTextCoroutine(TextMeshProUGUI textComponent, int targetValue)&#10;    {&#10;        // Получаем текущее значение из текста&#10;        int startValue = 0;&#10;        if (int.TryParse(textComponent.text.Replace(&quot;K&quot;, &quot;&quot;).Replace(&quot;M&quot;, &quot;&quot;), out int currentDisplayed))&#10;        {&#10;            startValue = currentDisplayed;&#10;        }&#10;        &#10;        float elapsedTime = 0f;&#10;        &#10;        while (elapsedTime &lt; animationDuration)&#10;        {&#10;            elapsedTime += Time.deltaTime;&#10;            float progress = elapsedTime / animationDuration;&#10;            float curveProgress = animationCurve.Evaluate(progress);&#10;            &#10;            int currentValue = Mathf.RoundToInt(Mathf.Lerp(startValue, targetValue, curveProgress));&#10;            textComponent.text = FormatCurrency(currentValue);&#10;            &#10;            // Эффект масштабирования&#10;            float scale = 1f + (0.1f * Mathf.Sin(progress * Mathf.PI));&#10;            textComponent.transform.localScale = Vector3.one * scale;&#10;            &#10;            yield return null;&#10;        }&#10;        &#10;        // Убеждаемся, что финальное значение точное&#10;        textComponent.text = FormatCurrency(targetValue);&#10;        textComponent.transform.localScale = Vector3.one;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopPurchaseHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopPurchaseHandler.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LoaderView.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LoaderView.cs" />
              <option name="originalContent" value="using System.Collections;&#10;// using DG.Tweening;&#10;using UnityEngine;&#10;&#10;public class LoaderView : MonoBehaviour&#10;{&#10;    private Coroutine _loadingCoroutine;&#10;&#10;    private bool _canRotate;&#10;&#10;    private void OnEnable()&#10;    {&#10;        _loadingCoroutine = StartCoroutine(DelayLoading());&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        StopCoroutine(_loadingCoroutine);&#10;    }&#10;&#10;    private IEnumerator DelayLoading()&#10;    {&#10;        int sec = 20;&#10;&#10;        while (sec-- &gt; 0)&#10;        {&#10;            // Vector3 targetLoadingRotation = new Vector3(0, 0, gameObject.transform.localRotation.eulerAngles.z+350);&#10;            //&#10;            // gameObject.transform.DORotate(targetLoadingRotation, 1f, RotateMode.WorldAxisAdd);&#10;            &#10;            yield return new WaitForSeconds(1.1f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;// using DG.Tweening;&#10;using UnityEngine;&#10;&#10;public class LoaderView : MonoBehaviour&#10;{&#10;    private Coroutine _loadingCoroutine;&#10;&#10;    private bool _canRotate;&#10;&#10;    private float _rotationSpeed = 100f;&#10;&#10;    private void OnEnable()&#10;    {&#10;        _loadingCoroutine = StartCoroutine(DelayLoading());&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        StopCoroutine(_loadingCoroutine);&#10;    }&#10;&#10;    private IEnumerator DelayLoading()&#10;    {&#10;        int sec = 20;&#10;&#10;        while (sec-- &gt; 0)&#10;        {&#10;            // Vector3 targetLoadingRotation = new Vector3(0, 0, gameObject.transform.localRotation.eulerAngles.z+350);&#10;            //&#10;            // gameObject.transform.DORotate(targetLoadingRotation, 1f, RotateMode.WorldAxisAdd);&#10;            &#10;            yield return new WaitForSeconds(1.1f);&#10;        }&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        RotateObject(_rotationSpeed);&#10;    }&#10;&#10;    private void RotateObject(float rotationSpeed)&#10;    {&#10;        transform.Rotate(Vector3.forward, rotationSpeed * Time.deltaTime);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>