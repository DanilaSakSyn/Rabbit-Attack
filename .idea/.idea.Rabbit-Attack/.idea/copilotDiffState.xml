<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/AnimatedTextDisplay.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/AnimatedTextDisplay.cs" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;using TMPro;&#10;&#10;public class AnimatedTextDisplay : MonoBehaviour&#10;{&#10;    public TextMeshProUGUI textElement;&#10;    public float animationDuration = 1f;&#10;    public float maxScale = 1.5f;&#10;&#10;    private Vector3 originalScale;&#10;&#10;    private void Awake()&#10;    {&#10;        if (textElement == null)&#10;        {&#10;            Debug.LogError(&quot;Text element is not assigned.&quot;);&#10;            return;&#10;        }&#10;&#10;        originalScale = textElement.transform.localScale;&#10;    }&#10;&#10;    public void DisplayText(string message)&#10;    {&#10;        if (textElement == null) return;&#10;&#10;        textElement.text = message;&#10;        StopAllCoroutines();&#10;        StartCoroutine(AnimateText());&#10;    }&#10;&#10;    private IEnumerator AnimateText()&#10;    {&#10;        float halfDuration = animationDuration / 2f;&#10;        float timer = 0f;&#10;&#10;        // Scale up&#10;        while (timer &lt; halfDuration)&#10;        {&#10;            timer += Time.deltaTime;&#10;            float scale = Mathf.Lerp(1f, maxScale, timer / halfDuration);&#10;            textElement.transform.localScale = originalScale * scale;&#10;            yield return null;&#10;        }&#10;&#10;        timer = 0f;&#10;&#10;        // Scale down&#10;        while (timer &lt; halfDuration)&#10;        {&#10;            timer += Time.deltaTime;&#10;            float scale = Mathf.Lerp(maxScale, 1f, timer / halfDuration);&#10;            textElement.transform.localScale = originalScale * scale;&#10;            yield return null;&#10;        }&#10;&#10;        textElement.transform.localScale = originalScale;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/LevelManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/LevelManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class LevelManager : MonoBehaviour&#10;{&#10;    private const string LevelKey = &quot;CurrentLevel&quot;;&#10;    private int currentLevel;&#10;&#10;    public AnimatedTextDisplay animatedTextDisplay;&#10;&#10;    private void Start()&#10;    {&#10;        LoadLevel();&#10;        DisplayLevel();&#10;    }&#10;&#10;    public void CompleteLevel()&#10;    {&#10;        currentLevel++;&#10;        SaveLevel();&#10;        DisplayLevel();&#10;    }&#10;&#10;    private void DisplayLevel()&#10;    {&#10;        if (animatedTextDisplay != null)&#10;        {&#10;            animatedTextDisplay.gameObject.SetActive(true);&#10;            animatedTextDisplay.DisplayText($&quot;Level {currentLevel}&quot;);&#10;        }&#10;    }&#10;&#10;    private void SaveLevel()&#10;    {&#10;        PlayerPrefs.SetInt(LevelKey, currentLevel);&#10;        PlayerPrefs.Save();&#10;    }&#10;&#10;    private void LoadLevel()&#10;    {&#10;        currentLevel = PlayerPrefs.GetInt(LevelKey, 1); // Default to level 1 if no data is saved&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopCurrencyDisplay.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopCurrencyDisplay.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;public class ShopCurrencyDisplay : MonoBehaviour&#10;{&#10;    [Header(&quot;Currency UI Elements&quot;)]&#10;    [SerializeField] private TextMeshProUGUI coinsText;&#10;    [SerializeField] private TextMeshProUGUI gemsText;&#10;    [SerializeField] private TextMeshProUGUI energyText;&#10;    [SerializeField] private TextMeshProUGUI livesText;&#10;    &#10;    [Header(&quot;Currency Icons&quot;)]&#10;    [SerializeField] private Image coinsIcon;&#10;    [SerializeField] private Image gemsIcon;&#10;    [SerializeField] private Image energyIcon;&#10;    [SerializeField] private Image livesIcon;&#10;    &#10;    [Header(&quot;Animation Settings&quot;)]&#10;    [SerializeField] private bool animateOnChange = true;&#10;    [SerializeField] private float animationDuration = 0.3f;&#10;    [SerializeField] private AnimationCurve animationCurve = AnimationCurve.EaseInOut(0, 1, 1, 1);&#10;    &#10;    private void OnEnable()&#10;    {&#10;        // Подписываемся на события изменения валют&#10;        Wallet.OnCoinsChanged += UpdateCoinsDisplay;&#10;        Wallet.OnGemsChanged += UpdateGemsDisplay;&#10;        Wallet.OnEnergyChanged += UpdateEnergyDisplay;&#10;        Wallet.OnLivesChanged += UpdateLivesDisplay;&#10;        &#10;        // Обновляем отображение при включении&#10;        if (Wallet.Instance != null)&#10;        {&#10;            UpdateAllDisplays();&#10;        }&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        // Отписываемся от событий&#10;        Wallet.OnCoinsChanged -= UpdateCoinsDisplay;&#10;        Wallet.OnGemsChanged -= UpdateGemsDisplay;&#10;        Wallet.OnEnergyChanged -= UpdateEnergyDisplay;&#10;        Wallet.OnLivesChanged -= UpdateLivesDisplay;&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        UpdateAllDisplays();&#10;    }&#10;    &#10;    private void UpdateAllDisplays()&#10;    {&#10;        if (Wallet.Instance != null)&#10;        {&#10;            UpdateCoinsDisplay(Wallet.Instance.Coins);&#10;            UpdateGemsDisplay(Wallet.Instance.Gems);&#10;            UpdateEnergyDisplay(Wallet.Instance.Energy);&#10;            UpdateLivesDisplay(Wallet.Instance.Lives);&#10;        }&#10;    }&#10;    &#10;    private void UpdateCoinsDisplay(int amount)&#10;    {&#10;        if (coinsText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(coinsText, amount);&#10;            else&#10;                coinsText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateGemsDisplay(int amount)&#10;    {&#10;        if (gemsText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(gemsText, amount);&#10;            else&#10;                gemsText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateEnergyDisplay(int amount)&#10;    {&#10;        if (energyText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(energyText, amount);&#10;            else&#10;                energyText.text = FormatCurrency(amount);&#10;        }&#10;    }&#10;    &#10;    private void UpdateLivesDisplay(int amount)&#10;    {&#10;        if (livesText != null)&#10;        {&#10;            if (animateOnChange)&#10;                AnimateText(livesText, amount);&#10;            else&#10;                livesText.text = amount.ToString();&#10;        }&#10;    }&#10;    &#10;    private string FormatCurrency(int amount)&#10;    {&#10;        if (amount &gt;= 1000000)&#10;            return (amount / 1000000f).ToString(&quot;F1&quot;) + &quot;M&quot;;&#10;        else if (amount &gt;= 1000)&#10;            return (amount / 1000f).ToString(&quot;F1&quot;) + &quot;K&quot;;&#10;        else&#10;            return amount.ToString();&#10;    }&#10;    &#10;    private void AnimateText(TextMeshProUGUI textComponent, int targetValue)&#10;    {&#10;        if (textComponent == null) return;&#10;        &#10;        StartCoroutine(AnimateTextCoroutine(textComponent, targetValue));&#10;    }&#10;    &#10;    private System.Collections.IEnumerator AnimateTextCoroutine(TextMeshProUGUI textComponent, int targetValue)&#10;    {&#10;        // Получаем текущее значение из текста&#10;        int startValue = 0;&#10;        if (int.TryParse(textComponent.text.Replace(&quot;K&quot;, &quot;&quot;).Replace(&quot;M&quot;, &quot;&quot;), out int currentDisplayed))&#10;        {&#10;            startValue = currentDisplayed;&#10;        }&#10;        &#10;        float elapsedTime = 0f;&#10;        &#10;        while (elapsedTime &lt; animationDuration)&#10;        {&#10;            elapsedTime += Time.deltaTime;&#10;            float progress = elapsedTime / animationDuration;&#10;            float curveProgress = animationCurve.Evaluate(progress);&#10;            &#10;            int currentValue = Mathf.RoundToInt(Mathf.Lerp(startValue, targetValue, curveProgress));&#10;            textComponent.text = FormatCurrency(currentValue);&#10;            &#10;            // Эффект масштабирования&#10;            float scale = 1f + (0.1f * Mathf.Sin(progress * Mathf.PI));&#10;            textComponent.transform.localScale = Vector3.one * scale;&#10;            &#10;            yield return null;&#10;        }&#10;        &#10;        // Убеждаемся, что финальное значение точное&#10;        textComponent.text = FormatCurrency(targetValue);&#10;        textComponent.transform.localScale = Vector3.one;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopPurchaseHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Project/Scripts/Shop/ShopPurchaseHandler.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>